function [ustar, vstar, pstar] = simple(nx, ny, bounds, Su, Sp, Lx, Ly, gama, ro, my_ep, alfaU, alfaV, alfaP, maxIter)
%hlavni funkce pro spusteni SIMPLu
%okrajove podminky jsou zadany pomoci rovnic
%nx - pocet objemu na ose x, ny - pocet kontrolnich objemu na ose y,
%bounds - okrajove podminky, Su,Sp - zdroje, Lx,Ly - delka oblasti v x,y
%gama - difuzni koeficinent, ro - hustota, my_ep - pozadovana presnot
%alfa - relaxace jednotlivych vypoctu
%ustar - napocitane rychlosti ve smeru osy x, vstar - ve smeru y
%pstar - tlaakove pole
deltaX = Lx/nx;
deltaY = Ly/ny;

[ustar, vstar, pstar] = initUVPstar(nx, ny, bounds);
[unx, uny] = size(ustar);
[vnx, vny] = size(vstar);
[pnx, pny] = size(pstar);

% ustar(:,1) = 0;
% ustar(8:14, 1) = 0.01;
nu = unx*uny;
Mu = sparse(nu, nu);
vectorU = zeros(nu, 1);
Bu = sparse(2*(unx+uny-2), nu);
vectorBu = zeros(2*(unx+uny-2),1);

nv = vnx*vny;
Mv = sparse(nv, nv);
vectorV = zeros(nv, 1);
Bv = sparse(2*(vnx+vny-2), nv);
vectorBv = zeros(2*(vnx+vny-2),1);
vold = zeros(vnx, vny);
uold = zeros(unx, uny);
sources = ones(pnx, pny);
it = 0;
while it < maxIter && ~convergence(sources(2:end-1,2:end-1), my_ep)
    it = it+1
   % ustar
    SU = zeros(unx, uny); SV = zeros(vnx, vny); SUp = zeros(unx, uny); SVp = zeros(vnx, vny);
    
    %spocita zdroje ktere vychazeji z toho ze na okrajich jsou zadane zdi
    [SUp, SVp, SU, SV] = calcSourceTermsArisingFromWalls(bounds, SUp, SVp, SU, SV, deltaX, deltaY, gama);
    

    %spocita zdroje, ktere vychazeji z hodnot tlaku
    SU = calcSourcesFromPressureForU(SU, pstar, unx, uny, deltaX, deltaY);
    SV = calcSourcesFromPressureForV(SV, pstar, vnx, vny, deltaX, deltaY);
    
    [FsForU, DsForU] = generateFsandDsForU(ustar, vstar, ro, gama, deltaX, deltaY); % generovani koeficientu pro vsechny rovnice
    [FsForV, DsForV] = generateFsandDsForV(ustar, vstar, ro, gama, deltaX, deltaY);

    [Mu, vectorU] = generateNonBoundaryEquations(SU, SUp, FsForU, DsForU, Mu, vectorU, unx, uny); % vygeneruje matici pro u s rovnicemi pro vsechny neokrajove prvky
    [Mu, vectorU] = relax(Mu, vectorU, alfaU, unx, uny, uold); % relaxace je uprostred aby nezmenily uz okrajove rovnice
    [Bu, vectorBu] = generateBoundaryEquations(bounds.u, Bu, vectorBu, unx, uny); % do matice mu vygeneruje rovnice pro okrajove prvky
    
    size(Mv)
    [Mv, vectorV] = generateNonBoundaryEquations(SV, SVp, FsForV, DsForV, Mv, vectorV, vnx, vny); %to same jako predtim pro v
    [Mv, vectorV] = relax(Mv, vectorV, alfaV, vnx, vny, vold);
    [Bv, vectorBv] = generateBoundaryEquations(bounds.v, Bv, vectorBv, vnx, vny);
    
    MatrixU = mergeMatrixAndBounds(Mu, Bu);
    MatrixV = mergeMatrixAndBounds(Mv, Bv);
    vectorUB = [vectorU; vectorBu];
    vectorVB = [vectorV; vectorBv];
    uold = ustar;
    vold = vstar;
    %vyreseni rovnic 
    ustar = MatrixU\vectorUB;
    ustar = ustar(1:end-2*(unx+uny-2));
    ustar = reshape(ustar, unx, uny);
    
    vstar = MatrixV\vectorVB;
    vstar = vstar(1:end-2*(vnx+vny-2));
    vstar = reshape(vstar, vnx, vny);

    [Mp, vectorP, sources] = generetaPresureCorrectEqs(pstar, ustar, vstar, ro, deltaX, deltaY, Mu, Mv, sources); % vytvoreni rovnci tlakovych korekci
    
     full(Mp)
     waitforbuttonpress;

    pcomma = pcg_chol(Mp, vectorP, my_ep);
    pcomma = reshape(pcomma, pnx, pny);
    
    %korekce
    pstar = correctP(pcomma, pstar, alfaP);
    ustar = correctU(pcomma, ustar, deltaY, Mu);
    vstar = correctV(pcomma, vstar, deltaX, Mv);
    
 %   [ustar, vstar] = checkOutlet(bounds, ustar, vstar);


    figure(1)
    mesh(ustar);
    figure(2)
    mesh(vstar);
    figure(3)
    mesh(pstar);
     waitforbuttonpress;
%  
    
end
end